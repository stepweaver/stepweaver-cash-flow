import { formatCurrency, formatDate, formatDateForDisplay } from './utils';
import JSZip from 'jszip';

// Export to CSV format
export const exportToCSV = (data, filename = 'export.csv') => {
  if (!data || data.length === 0) return;

  // Get headers from first object
  const headers = Object.keys(data[0]);

  // Create CSV content
  const csvContent = [
    headers.join(','),
    ...data.map(row =>
      headers.map(header => {
        const value = row[header];
        // Handle values that need quotes (contain commas, quotes, or newlines)
        if (typeof value === 'string' && (value.includes(',') || value.includes('"') || value.includes('\n'))) {
          return `"${value.replace(/"/g, '""')}"`;
        }
        return value;
      }).join(',')
    )
  ].join('\n');

  // Create and download file
  const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
  const link = document.createElement('a');
  const url = URL.createObjectURL(blob);
  link.setAttribute('href', url);
  link.setAttribute('download', filename);
  link.style.visibility = 'hidden';
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
};

// Export to JSON format
export const exportToJSON = (data, filename = 'export.json') => {
  if (!data) return;

  const jsonContent = JSON.stringify(data, null, 2);
  const blob = new Blob([jsonContent], { type: 'application/json;charset=utf-8;' });
  const link = document.createElement('a');
  const url = URL.createObjectURL(blob);
  link.setAttribute('href', url);
  link.setAttribute('download', filename);
  link.style.visibility = 'hidden';
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
};

// Generate PDF HTML content
export const generatePDFHTML = (data, title = 'Export Report') => {
  const currentDate = new Date().toLocaleDateString();

  return `
    <!DOCTYPE html>
    <html>
    <head>
      <title>${title}</title>
      <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .header { text-align: center; margin-bottom: 30px; }
        .summary { margin-bottom: 30px; }
        .summary-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 20px; }
        .summary-item { padding: 15px; border: 1px solid #ddd; border-radius: 5px; }
        .summary-label { font-weight: bold; color: #666; }
        .summary-value { font-size: 18px; margin-top: 5px; }
        table { width: 100%; border-collapse: collapse; margin-top: 20px; }
        th, td { padding: 10px; text-align: left; border-bottom: 1px solid #ddd; }
        th { background-color: #f5f5f5; font-weight: bold; }
        .amount { text-align: right; }
        .footer { margin-top: 30px; text-align: center; color: #666; font-size: 12px; }
      </style>
    </head>
    <body>
      <div class="header">
        <h1>${title}</h1>
        <p>Generated on ${currentDate}</p>
      </div>
      
      <div class="summary">
        <h2>Summary</h2>
        <div class="summary-grid">
          <div class="summary-item">
            <div class="summary-label">Total Revenue</div>
            <div class="summary-value">${formatCurrency(data.totalRevenue || 0)}</div>
          </div>
          <div class="summary-item">
            <div class="summary-label">Total Expenses</div>
            <div class="summary-value">${formatCurrency(data.totalExpenses || 0)}</div>
          </div>
          <div class="summary-item">
            <div class="summary-label">Total Draws</div>
            <div class="summary-value">${formatCurrency(data.totalDraws || 0)}</div>
          </div>
          <div class="summary-item">
            <div class="summary-label">Net Income</div>
            <div class="summary-value">${formatCurrency(data.netIncome || 0)}</div>
          </div>
        </div>
      </div>
      
      <h2>Transactions</h2>
      <table>
        <thead>
          <tr>
            <th>Date</th>
            <th>Description</th>
            <th>Type</th>
            <th class="amount">Amount</th>
          </tr>
        </thead>
        <tbody>
          ${(data.transactions || []).map(transaction => `
            <tr>
              <td>${formatDate(transaction.date)}</td>
              <td>${transaction.description || ''}</td>
              <td>${transaction.type || ''}</td>
              <td class="amount">${formatCurrency(transaction.amount || 0)}</td>
            </tr>
          `).join('')}
        </tbody>
      </table>
      
      <div class="footer">
        <p>Report generated by StepWeaver Cash Flow</p>
      </div>
    </body>
    </html>
  `;
};

// Download file helper
export const downloadFile = (content, filename, mimeType = 'text/plain') => {
  const blob = new Blob([content], { type: mimeType });
  const link = document.createElement('a');
  const url = URL.createObjectURL(blob);
  link.setAttribute('href', url);
  link.setAttribute('download', filename);
  link.style.visibility = 'hidden';
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
};

// Download receipts as ZIP with proper JSZip functionality
export const downloadReceiptsAsZip = async (receipts, dateRange, tokenManager = null) => {
  if (!receipts || receipts.length === 0) {
    console.warn('No receipts to download');
    return;
  }

  console.log(`Processing ${receipts.length} receipts for ZIP download`);

  try {
    const zip = new JSZip();
    let successfulReceipts = 0;

    // Process each receipt
    for (let index = 0; index < receipts.length; index++) {
      const receipt = receipts[index];
      console.log(`Processing receipt ${index + 1}/${receipts.length}:`, {
        name: receipt.name,
        hasData: !!receipt.data,
        hasUrl: !!receipt.url,
        storageType: receipt.storageType,
        type: receipt.type,
        id: receipt.id,
        dataPreview: receipt.data ? receipt.data.substring(0, 50) + '...' : 'none'
      });

      if (!receipt.data && !receipt.url) {
        console.warn(`Receipt ${index + 1} has no data or URL, skipping`);
        continue;
      }

      // Use original receipt name, or create a meaningful fallback
      let filename;
      if (receipt.name) {
        // Use original filename, but sanitize it for cross-platform compatibility
        filename = receipt.name.replace(/[<>:"/\\|?*]/g, '_');
      } else {
        // Fallback to transaction description with index
        const fileExtension = receipt.type?.split('/')[1] || 'bin';
        const transactionDesc = receipt.transactionDescription || 'receipt';
        filename = `${transactionDesc.replace(/[^a-z0-9]/gi, '_')}_${index + 1}.${fileExtension}`;
      }

      try {
        if (receipt.data && receipt.data.startsWith('data:')) {
          // Handle base64 data (Firestore storage)
          console.log(`Processing base64 receipt: ${filename}`);
          const binaryData = atob(receipt.data.split(',')[1]);
          const bytes = new Uint8Array(binaryData.length);
          for (let i = 0; i < binaryData.length; i++) {
            bytes[i] = binaryData.charCodeAt(i);
          }
          zip.file(filename, bytes, { binary: true });
        } else if (receipt.data || receipt.url) {
          // Handle download URL (Firebase Storage) via proxy API
          console.log(`Fetching receipt via proxy: ${filename}`);

          // Extract receipt ID from the receipt object
          // We need to get the receipt ID to use our proxy API
          const receiptId = receipt.id || receipt.receiptId;

          if (!receiptId) {
            console.error(`No receipt ID found for ${filename}, skipping`);
            continue;
          }

          // Get auth token using token manager
          if (!tokenManager) {
            console.error('No token manager available for receipt download');
            continue;
          }

          let token;
          try {
            token = await tokenManager.getScopedToken('read_business_transactions');
          } catch (tokenError) {
            console.error('Failed to get auth token for receipt download:', tokenError);
            continue;
          }

          try {
            const response = await fetch(`/api/receipts/${receiptId}`, {
              headers: {
                'Authorization': `Bearer ${token}`
              }
            });

            if (!response.ok) {
              console.error(`Failed to fetch receipt ${filename} via proxy: ${response.status}`);
              continue;
            }

            const blob = await response.blob();
            zip.file(filename, blob);
            successfulReceipts++;
            console.log(`✅ Successfully added receipt ${index + 1} to ZIP: ${filename}`);
          } catch (proxyError) {
            console.error(`❌ Error fetching receipt ${filename} via proxy:`, proxyError);
            continue;
          }
        }
      } catch (receiptError) {
        console.error(`❌ Error processing receipt ${filename}:`, receiptError);
        // Continue with other receipts
      }
    }

    // Check if we have any files in the ZIP
    const fileCount = Object.keys(zip.files).length;
    if (fileCount === 0) {
      console.warn('No valid receipts found to include in ZIP');
      alert('No valid receipts found to export.');
      return;
    }

    console.log(`Generating ZIP file with ${fileCount} receipts (${successfulReceipts} successful)...`);

    // Generate the ZIP file
    const zipBlob = await zip.generateAsync({ type: 'blob' });

    // Download the ZIP file
    const link = document.createElement('a');
    const url = URL.createObjectURL(zipBlob);
    link.setAttribute('href', url);
    link.setAttribute('download', `business_receipts_${dateRange}.zip`);
    link.style.visibility = 'hidden';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);

    // Clean up the URL object
    URL.revokeObjectURL(url);

    console.log(`✅ Successfully downloaded ${fileCount} receipts as ZIP (${successfulReceipts}/${receipts.length} processed successfully)`);
  } catch (error) {
    console.error('Error creating ZIP file:', error);
    alert('Failed to create ZIP file. Please try again or contact support.');
  }
};
